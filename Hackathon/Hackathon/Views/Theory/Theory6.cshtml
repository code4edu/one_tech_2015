@{
    Layout = "~/_SiteLayout.cshtml";
    Page.Title = "Урок 6";
}

<div class="page-header">
    <h1>Урок 6</h1>
</div>

Ну вот мы и подбираемся к фундаменту C#. Сегодня мы поговорим с вами о такой структуре данных, как массив и завершим серию уроков по циклам последним их представителем — циклом для каждого (foreach).
<br><br>Если вы практиковались в программировании, то наверняка могли обратить внимание на то, что порой несколько переменных одного типа гораздо удобнее было бы объединить в некоторое множество. Например, в программе нужно обрабатывать фамилии класса, группы или коллег по работе.
<br><br>Безусловно, можно спокойно объявлять переменные в таком количестве, сколько они понадобятся. У вас тридцать сотрудников? Сделаем тридцать переменных, что нам это стоит. 300 сотрудников? Трудно, но не беда. 3000? 
<br><br>Я не случайно предварил тему о массивах циклами. Сейчас вы поймете для чего я это сделал.

<br><br>Итак, вернемся к нашей многострадальной задаче о сотрудниках. Допустим, нам нужно будет вести список всех сотрудников по фамилиям. Зная о циклах, мы легко можем автоматизировать ввод этих фамилий. Нам просто нужно будет объявлять переменные для их хранения. Однако тут мы столкнемся с одним но. Цикл всего лишь автоматизирует участок кода, а нам нужно будет сделать так, чтобы фамилии хранились в разных переменных, иначе мы рискуем переписывать их многократно и не справится с задачей. Мы могли бы поступить так:
<code><br><br>
string sotr1,sotr2,sotr3,sotr4,sotr5;<br>
    <br>
Console.WriteLine (“Введите фамилию сотрудника”);<br>
    <br>
sotr1=Console.ReadLine ();<br>
    <br>
Console.WriteLine (“Введите фамилию сотрудника”);<br>
    <br>
sotr2=Console.ReadLine ();<br>
    <br>
Console.WriteLine (“Введите фамилию сотрудника”);<br>
    <br>
sotr3=Console.ReadLine ();<br>
    <br>
Console.WriteLine (“Введите фамилию сотрудника”);<br>
    <br>
sotr4=Console.ReadLine ();<br>
    <br>
Console.WriteLine (“Введите фамилию сотрудника”);<br>
    <br>
sotr5=Console.ReadLine ();<br>
    </code>
<br><br>Как видите, цикл сам напрашивается собой. Мы могли бы занести в тело цикла ввод фамилии и вывод надписи о том, что нужно ввести эту самую фамилию. Однако в нашем примере у нас есть пять переменных. Если мы будем ставить одну из этих переменных в цикл, то ничего у нас не выйдет (попробуйте сами).
<br><br>Не кажется ли вам, что гораздо проще будет сделать некую абстрактную переменную, допустим sotr, и приращивать к ней по единице? Ведь у нас вопрос сразу решится.
<br><br>Увы, теми средствами, что мы сейчас знаем, это нельзя сделать. В этом случае нам придется воспользоваться массивами.
<br><br>Что такое массив? Это набор элементов одного типа, имеющий общее имя. Так как это набор элементов, то к каждому элементу, входящий в массив можно обратиться по его индексу.
<br><br>Синтаксис массива в C# несколько отличается от C или C++. Дело в том, что на C# нужно не только объявить массив, но и выделить для него память.
<br><br>Давайте я поясню, что это означает. Помните, я говорил, что переменные в C# хранятся в стеке, а объекты — в куче (или хипе, кто как привык). Стек удобный и быстрый, но за это удобство нужно расплачиваться. Такой платой является ограниченный размер стека. Если мы запихнем в стек большие структуры данных, мы получим любимый хакерами «stack overflow» или переполнение стека. Чтобы этого не произошло, массивы и объекты помещают в кучу, представляющую собой нечто иное как оперативную память компьютера.
<br><br>В C++ (равно как и в C) массив почти тоже самое, что и указатель. Это означает, что массив автоматически размещается в куче, хотя там также можно создавать и динамические массивы.
<br><br>В C# указатели хотя и имеются, но код с ними считается небезопасным и сопряжен с некоторыми трудностями компиляции (нужно будет «убедить» вашу среду разработки в том, что код можно запускать. Об этом мы поговорим в отдельном уроке). Поэтому для массива по указанным выше причинам необходимо выделять память.
<br><br>Итак, мы знаем, что массив — это набор переменных одного типа, имеющий общее имя. Поэтому его объявление выглядит так:
<br>тип_данных [] имя_массива;
<br><br>Обратите внимание на квадратные скобки — они как раз и указывают C# о том, что это массив. В качестве типов данных могут выступать и пользовательские, такие как структуры и объекты, но о них поговорим в других уроках.
<br><br>Теперь, применяя эти знания в задаче с сотрудниками, у нас получится такое объявление:
<br>string [] sotr;
<br><br>Мы объявили массив, но пользоваться им еще не можем. Чтобы начать его использовать, нам нужно выделить память. Делается это так:
<br>new string [размер_массива];
<br><br>В квадратных скобках указывается размер в цифрах. Чтобы сэкономить место в коде, обычно в C# (равно как и в Java) объявление массива объединяют вместе с выделением памяти для него:
<code><br>
string [] sotr=new string [5];<br><br>
    </code>
<br><br>Не хочу этот урок делать слишком длинным, поэтому могу сказать, что это — одномерный массив. Есть еще и двумерный, и трехмерный, и так называемый зубчатый массив, разреженный массив и т. д. О некоторых мы поговорим в другом уроке. Но обычно применяются максимум двумерные массивы.
<br><br>Доступ к элементам массива осуществляется по индексу, причем его отсчет начинается с 0. Однако прежде чем обратиться к элементу массива, его нужно туда поместить. Сделать это можно двумя способами: при инициализации и при явном присвоении элементу массива нужного значения. Давайте посмотрим, как это делается.
<br><br>Массив можно объявлять при инициализации. Этот способ весьма удобен, когда мы знаем наперед количество элементов массива и его состав. Например, наш список сотрудников будет выглядеть примерно таким образом:
<br>
<code>
string [] sotr={“Иванов”,”Петров”,”Сидоров”,”Борисов”,”Сергеев”};<br><br>
    </code>
<br><br>Мы получим массив из пяти элементов, содержащих фамилии сотрудников. Таким образом часто полезно создавать массивы при написании методов преобразования чисел в строчные эквиваленты (особенно это актуально при написании бухгалтерских программ) и т.п.
<br><br>Тем не менее, достаточно часто массивы бывают просто огромными по своей структуре. Представьте себе инициализацию массива, в который нужно внести 1000 или 10000 фамилий. Представляете себе размер кода?
<br><br>Гораздо проще будет вносить данные в массив традиционным способом – поэлементно. В этом случае нам нужно будет создать массив и вносить в него нужные данные.
<br><code>
string [] sotr=new string [10];<br>
    <br>
sotr[0]=”Иванов”;<br>
    <br>
...<br>
    <br>
sotr [9]=”Михайлов”;<br>
    </code><br><br>
Хорошо, скажете вы, но в чем же выгода массива? Ведь мы могли 10 раз написать различные переменные с нужными фамилиями и задача бы была выполнена. Кроме того, забегая несколько вперед, скажу, что предыдущий фрагмент можно смело назвать китайским кодом. Нормальные программисты так не пишут.
<br><br>Что дает нам массив? Теперь мы можем манипулировать его элементами в цикле, обращаясь по индексу. А это означает, что теперь мы можем и отсортировать содержимое массива и т.д.
<br><br>Смотрите, как теперь можно ввести данные о сотрудниках в массив, используя цикл.<br><br>
<code>
for (int i=0; i<sotr.length;i++) {
    <br>

    console.writeline (“введите фамилию сотрудника”);
    <br>
    sotr[i]=Console.ReadLine ();
    <br>
    }
    console.readkey();<br>
</code>
<br><br>
                                вставьте этот код в метод main и запустите его на компиляцию. видите, насколько более гибок данный подход? мы перекладываем задачу по наполнению массива уже на пользователя программы и он может вносить туда буквально все (особенно, в нашей программе, в которой напрочь отсутствуют проверки ввода данных ) ) потом мы можем написать метод, который запишет наш массив в файл и потом уже из него его считывать при запуске программы. но об этом в других уроках.
                           <br><br>     так как мы знаем количество элементов массива, то нам идеально подходит цикл с параметром, чем я и не преминул воспользоваться. наверняка вас обескуражила запись условия i
    <sotr.length. дело в том, что массив – это объект. и у него есть куча своих методов и свойств. length возвращает количество элементов массива. мы могли бы написать i
        <10 и код бы выполнился, но здесь чревато ошибиться с вводом диапазона. поэтому гораздо удобнее работать именно с методами массива.
            <br><br>        однако предостерегу вас от возможных ошибок. у меня в этом коде перебирается всего 10 элементов, поэтому я могу вольготно вызывать метод (точнее, это свойство). однако часто в программах нужно будет манипулировать с тысячами элементов. если писать так, как в этом участке кода, вы столкнетесь с неизбежной проблемой производительности, так как постоянно придется вызывать это свойство. чтобы избежать этого, нужно просто считать количество элементов массива в отдельную переменную и работать уже с ней
            <br><br>
        <code>
            long len=sotr.Length;<br>
            int i=0;<br>
            while (i<len)<br>
    {
    <br>
    console.readline (sotr[i]);
    <br>
    i++;<br>
    <br>
    }<br>
</code>
            <br><br>   не пугайтесь, это просто разновидность предыдущего кода.
            <br><br>    пока мы оставим в покое массивы до следующего урока, а сейчас рассмотрим последний цикл foreach.
            <br><br>      цикл foreach
            <br><br>      в c# имеется замечательный цикл ля перебора элементов любого множества значений. вы видели, что я использовал циклы с пред условием и с параметром для перебора элементов массива. например, для вывода элементов массива мне бы пришлось писать примерно такой код
                  
                  for (int i=0;i<sotr.length;i++)
    <br>
    console.writeline (sotr[i]);<br><br>
                                    <br>   однако такой код может показаться несколько громоздким. поэтому гораздо проще использовать цикл foreach (при переборе коллекций он вообще незаменим)
   <code>
    foreach(string s in sotr)
    console.writeline(s);
       </code>

                                    <br><br> синтаксис такого цикла выглядит так
                                    <br><br>  foreach (тип_переменной-цикла имя_переменной in набор_значений)
                                    <br><br>  часто его не любят применять новички, однако при работе с другими наборами значений вы поймете всю прелесть это цикла.
                                    <br><br>  напоследок давайте рассмотрим еще один оператор прерывания цикла –continue. если break полностью прерывает цикл, то continue вызывает очередную итерацию. несмотря на то, что в примере я буду использовать цикл для каждого, continue применяется во всех типах циклов, учтите это.
                                    <br><br>  итак, у нас стоит задача найти количество однофамильцев сидорова среди сотрудников. мы будем решать ее таким образом (учтите, это далеко не самый правильный способ, просто он пришел мне в голову в качестве примера использования continue)
  <code><br>
    string []sotr={"Иванов","Петров","Сидоров","Борисов","Сергеев","Сидоров"};<br>
    int k=0; //счетчик однофамильцев<br>
      <br>
    foreach(string s in sotr)<br>
      <br>
    {<br>
      <br>
    if (s=="Сидоров")<br>
      <br>
    {<br>
      <br>
    k++;<br>
      <br>
    continue;<br>
      <br>
    }<br>
      <br>
    Console.WriteLine (s);<br>
      <br>
    }<br>
      <br>
    Console.WriteLine ("Сидоров");<br>
      <br>
    Console.WriteLine("У вас {0} Сидорова",k);<br>
      </code>
